from fxpmath import Fxp

"""
==========================================================================================================
  Author      : Gaetano Sferrazza
  Description : Python script used to test the behavior of the circuit that implements a filter
                (Squared Root Raised Cosine) SRRC_Fir, in various cases and more precisely
                'boundary_tests: overflow, saturation, limit cases, etc.'. It therefore
                serves as a useful support tool to compare the values obtained with the
                results of the simulation conducted on ModelSim via its testbench (SRRC_Filter_boundery_tb).
                This will allow verifying if the results are consistent with those generated by this script
                (high-level), as they represent the expected values in case everything functions correctly.
                
  Purpose     : Created during the development of the project required for the
                'Electronics & Communications Systems' course exam - University of Pisa.

  Note: ModelSim is a digital circuit simulator used for functional verification of
        hardware designs described in VHDL, Verilog, or SystemVerilog.
==========================================================================================================

"""
# ------------------------------------------------------------
# Utility Functions
# ------------------------------------------------------------
def real_to_q8_7(real_value):
    """
    Converts the real value passed as a parameter to Q8.7 format, i.e., multiplied by 2^7.
    This is done using the "Fxp" function, which extracts the Fixed Point value from which
    the values of interest can then be extrapolated, in our case the Integer Raw.

    Parameters:
        float value: Real value to convert.
    Returns:
        int: Q8.7 format of the float value parameter
    """
    x = Fxp(real_value, signed=True, n_word=16, n_frac=7)
    integer_q8_7_value = x.val
    return integer_q8_7_value


def convolution_single_input(real_value, coefficients):
    """
    Calculates the weighted sum of coefficients with a specific multiplier.

    Parameters:
        coefficients (list or iterable): Array of numerical coefficients.
        multiplier: Value to multiply each coefficient by. The Q8.7 format
                    value should be used, i.e., multiplied by 2^7.
    Returns:
        int: Sum of coefficients multiplied by the multiplier.
    """
    input_q8_7 = real_to_q8_7(real_value)
    return sum(input_q8_7 * coeff for coeff in coefficients)


def convolution_multiple_input(real_value_array, coefficients):
    """
    Calculates the convolution between real_value_array (converted to Q8.7) and coefficients.

    Parameters:
        real_value_array (list of float): Real floating-point values.
        coefficients (list of int): Integer coefficients.

    Returns:
        int: Sum of products input_q8_7 * coeff
    """
    if len(real_value_array) != len(coefficients):
        raise ValueError(f"in_arr: {len(real_value_array)} Length of values and coefficients must be the same.")

    total_sum = 0
    for val, coeff in zip(real_value_array, coefficients):
        input_q8_7 = real_to_q8_7(val)  # Converts the real value to Q8.7 (integer)
        total_sum += input_q8_7 * coeff      # Integer product (Q8.7 * coefficient)

    return total_sum


def generate_sequence (values_to_shift):
    """
    Generates a list of sequences by progressively shifting elements.

    The first sequence is created by repeating `values_to_shift` to a certain length.
    Subsequent sequences are generated by taking the first element of `values_to_shift`
    and prepending it to a shifted version of the previous sequence (removing the last element).

    Parameters:
        values_to_shift (list): The initial values used to generate the sequences.

    Returns:
        list: A list of generated sequences.
    """
    initial_sequence = values_to_shift * 12
    initial_sequence = initial_sequence[:23]

    num_sequences = 23
    sequences = []

    for i in range(num_sequences):
        if i == 0:
            sequences.append(initial_sequence)
        else:
            new_seq = [values_to_shift[0]] + sequences[-1][:-1]
            sequences.append(new_seq)

    return sequences


def print_shift_conv_result (real_input_val, scaled_total_sum):
    """
    Prints a detailed analysis of the total sum result of a convolution,
    specifically tailored for sliding-window behavior in the SRRC filter.

    This function displays the real and scaled expected values, as well as
    the pre- and post-truncation results of the filter output,
    useful for comparison with hardware simulation tools like ModelSim.

    Parameters:
        real_input_val (list of float): The real input values used for the convolution.
        scaled_total_sum (int): The total scaled sum (Q13.21) resulting from the convolution.
    """
    print("\n#------------------------------------------------------------------------------------")
    print("#\t Analysis of the Total Sum Result of the Convolution (Sliding-Window)")
    print("#------------------------------------------------------------------------------------")

    real_tot_sum = scaled_total_sum * pow(2,-21)

    print("\n-- @ Expected Values @ --")
    print(f"\n1) Real Value of total sum with:", end = " ")
    print(f"{real_input_val[0]}, {real_input_val[1]}, {real_input_val[2]}...{real_input_val[22]} as input is: {real_tot_sum:.5f}")
    print(f"2) Scaled Value (Q13.21) of total sum with:", end = " ")
    print(f"{real_to_q8_7(real_input_val[0])}, {real_to_q8_7(real_input_val[1])}, {real_to_q8_7(real_input_val[2])}...{real_to_q8_7(real_input_val[22])} as input is: {scaled_total_sum}")

    print("\n-- @ Filter Output Results Pre-Truncation @ --")
    tot_sum_truncation_results = truncation_filter_output(scaled_total_sum)
    print(f"\n3) Full-Binary Value of the total sum (35-bit): {tot_sum_truncation_results[0]}")
    print(f"4) Full-Raw integer value of the total sum (Fixed Point): {tot_sum_truncation_results[1]}")

    print("\n-- @ Filter Output Results Post-Truncation @ --")
    print("-- @ Use for comparison with ModelSim results @ --\n")
    print(f"5) Binary SRRC_filter_out Value (Total Sum)        : {tot_sum_truncation_results[2]}")
    print(f"6) Raw Integer SRRC_filter_out Value (Total Sum)   : {tot_sum_truncation_results[3]}")
    print(f"7) Real SRRC_filter_out Value (Total Sum - Q11.4) : {tot_sum_truncation_results[4]}")
    print("---------------------------------------------------------------------------------------")


def print_sliding_results(list_of_sequences, scaled_coeffs):
    """
    Iterates through a list of input sequences, performs a multiple-input convolution
    for each sequence, and then prints the detailed convolution results.

    This function is used to demonstrate the "sliding-window" behavior of the filter.

    Parameters:
        list_of_sequences (list of list of float): A list where each element is
                                                   an input sequence for convolution.
        scaled_coeffs (list of int): The scaled coefficients (Q1.14) used in the convolution.
    """
    idx = 0
    for ith_seq in list_of_sequences:
        print(f"\n[ Sequence to index: ({idx}) ]")
        conv_i = convolution_multiple_input(ith_seq, scaled_coeffs)
        print_shift_conv_result(ith_seq, conv_i)
        idx=idx+1


def truncation_filter_output (value_to_truncate):
    """
    Performs truncation of an integer value in Q13.21 fixed-point format to a
    16-bit value in Q11.4 format (used as filter output), simulating the
    hardware bit slicing behavior.

    Parameters:
        value_to_truncate (int): Scaled value to truncate (in Q13.21).

    Returns:
        list:
            [0] -> 35-bit binary string (complete, pre-truncation)
            [1] -> complete raw integer (pre-truncation)
            [2] -> truncated binary string (16 bit, Q11.4)
            [3] -> integer interpreted from truncated binary
            [4] -> real value calculated from Q11.4
    """
    # Conversion to Signed Fixed Point format
    fxp_35_bit_format = Fxp(value_to_truncate, signed=True, n_word=35, n_frac=0)
    # Before truncation - Full 35-bit
    full_binary = fxp_35_bit_format.bin()
    full_raw_integer = fxp_35_bit_format.val

    # - For a 35-bit number (indexed from 34 to 0), select bits from 32 to 17
    # - Python slicing is [start:end], with 'end' exclusive -> 18
    truncated_binary_str = fxp_35_bit_format.bin()[2:18] # extraction of 16 bits (32 downto 17)
    # These 16 bits now represent a new fixed-point format.
    # The output format is Q11.4 (1 sign bit + 11 integer + 4 fractional = 16 bits).
    if truncated_binary_str[0] == '1':  # negative (sign bit = 1)
        truncated_integer_val = int(truncated_binary_str, 2) - (1 << 16)
    else:
        truncated_integer_val = int(truncated_binary_str, 2)
    # Calculate the real value by interpreting the truncated value as Q11.4
    real_output_value = truncated_integer_val * pow(2, -4)

    return [full_binary, full_raw_integer, truncated_binary_str, truncated_integer_val, real_output_value]


def print_conv_results (real_input_val, real_coeff_arr, scaled_coeff_arr, scaled_total_sum):
    """
    Prints a detailed analysis of SRRC convolution results, both for the central value
    (impulse response peak) and for the total sum of the convolution.

    Parameters:
        real_input_val (float or list of float): Single real input or array of real values.
        real_coeff_arr (list of float): Array of real coefficients.
        scaled_coeff_arr (list of int): Array of scaled coefficients (Q1.14).
        scaled_total_sum (int): Total scaled sum (Q13.21), resulting from the convolution.

    The result includes:
        - Real and scaled values (Q8.7) for the input.
        - Central product value and its binary representation (pre/post truncation).
        - Total sum value and its binary representation (pre/post truncation).
        - Useful conversions for comparison with external tools (e.g., ModelSim).
    """
    is_array_input = False
    if isinstance(real_input_val, (list, tuple)) or hasattr(real_input_val, '__getitem__'):
        try:
            real_input = real_input_val[11]
            is_array_input = True
        except IndexError:
            raise ValueError("The array does not contain at least 11 elements.")
    else:
        real_input = real_input_val
        is_array_input = False

    input_q8_7 = real_to_q8_7(real_input)
    real_central_prod = real_input * real_coeff_arr[11]
    scaled_central_prod = input_q8_7 * scaled_coeff_arr[11]

    print("\n#---------------------------------------------------------------------------------")
    print("#\t1) Analysis of the Central Coefficient Value (Impulse Response Peak)")
    print("#---------------------------------------------------------------------------------")

    print(f"\n\t- @ Input Value Details -> 1) Real: {real_input}")
    print(f"\t\t\t\t   2) Q8.7 Format: {input_q8_7}")
    print(f"\n\t- @ Central Coefficient -> 1) Real: {real_coeff_arr[11]}")
    print(f"\t\t\t\t   2) Q1.14 Format: {scaled_coeff_arr[11]}")

    print("\n-- @ Expected Values @ --")
    print(f"\n1) Real Value of the Convolution (Peak) is [ {real_input} * {real_coeff_arr[11]}] : {real_central_prod:.5f}")
    print(f"2) Scaled Value of the (Peak) is [ ({real_input} * 2^7) * ({real_coeff_arr[11]} * 2^14) = {input_q8_7} * {scaled_coeff_arr[11]} ] = {scaled_central_prod}")

    print("\n-- @ Filter Output Results Pre-Truncation @ --")
    central_prod_truncation_results = truncation_filter_output(scaled_central_prod)
    print(f"\n3) Full-Binary Value of the Convolution (Peak) (35-bit): {central_prod_truncation_results[0]}")
    print(f"4) Full-Raw integer value of the Convolution (Peak) (Fixed Point): {central_prod_truncation_results[1]}")

    print("\n-- @ Filter Output Results Post-Truncation @ --")
    print("-- @ Use for comparison with ModelSim results @ --\n")
    print(f"5) Binary SRRC_filter_out (Peak Value)              : {central_prod_truncation_results[2]}")
    print(f"6) Raw Integer SRRC_filter_out (Peak Value)         : {central_prod_truncation_results[3]}")
    print(f"7) Real SRRC_filter_out Value (Peak Value - Q11.4)  : {central_prod_truncation_results[4]}")
    print("-------------------------------------------------------------------------------------")

    print("\n#------------------------------------------------------------------------------------")
    print("#\t2) Analysis of Total Sum Result (Full Convolution Value)")
    print("#------------------------------------------------------------------------------------")

    real_tot_sum = scaled_total_sum * pow(2,-21)

    print("\n-- @ Expected Values @ --")
    if is_array_input:
        print(f"\n1) Real Value of total sum with:", end = " ")
        print(f"{real_input_val[0]}, {real_input_val[1]}, {real_input_val[2]}...{real_input_val[22]} as input is: {real_tot_sum:.5f}")
        print(f"2) Scaled Value (Q13.21) of total sum with:", end = " ")
        print(f"{real_to_q8_7(real_input_val[0])}, {real_to_q8_7(real_input_val[1])}, {real_to_q8_7(real_input_val[2])}...{real_to_q8_7(real_input_val[22])} as input is: {scaled_total_sum}")
    else:
        print(f"\n1) Real Value of total sum with {real_input} as input is: {real_tot_sum:.5f}")
        print(f"2) Scaled Value (Q13.21) of total sum with {input_q8_7} as input is = {scaled_total_sum}")

    print("\n-- @ Filter Output Results Pre-Truncation @ --")
    tot_sum_truncation_results = truncation_filter_output(scaled_total_sum)
    print(f"\n3) Full-Binary Value of the total sum (35-bit): {tot_sum_truncation_results[0]}")
    print(f"4) Full-Raw integer value of the total sum (Fixed Point): {tot_sum_truncation_results[1]}")

    print("\n-- @ Filter Output Results Post-Truncation @ --")
    print("-- @ Use for comparison with ModelSim results @ --\n")
    print(f"5) Binary SRRC_filter_out Value (Total Sum)        : {tot_sum_truncation_results[2]}")
    print(f"6) Raw Integer SRRC_filter_out Value (Total Sum)   : {tot_sum_truncation_results[3]}")
    print(f"7) Real SRRC_filter_out Value (Total Sum - Q11.4)  : {tot_sum_truncation_results[4]}")
    print("---------------------------------------------------------------------------------------")



# ------------------------------------------------------------
# Test SRRC_FIR-Filter
# ------------------------------------------------------------
def srrc_filter_test():
    # Symmetric SRRC_Filter Coefficients
    real_coeff = [
        -0.0165, -0.0150,  0.0155,  0.0424,  0.0155, -0.0750,
        -0.1568, -0.1061,  0.1568,  0.5786,  0.9745,  1.1366,
        0.9745,  0.5786,  0.1568, -0.1061, -0.1568, -0.0750,
        0.0155,  0.0424,  0.0155, -0.0150, -0.0165
    ]
    scaled_coeff = [] # real_coeff[i] * 2^14

    print("Coefficients: \n")
    index = 0
    for i in real_coeff:
        print("Coefficient " + str(index))
        x = Fxp(i, signed=True, n_word=16, n_frac=14)
        print("1) Real Value: ", x) # float value
        print("2) Binary Value: ", x.bin()) # binary as it would be stored in a 16-bit hardware register (in 2's complement, given signed=True)
        print("3) Integer Value (Format Q1.14): ", x.val) # The Integer “Raw” Value (Scaled) -> x * 2^14
        scaled_coeff.append(x.val)
        index=index+1
        print("\n")


    print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
    print("\n    \t1) Format Selection for Input, Coefficients, and Output of the SRRC_FIR_Filter")
    print("\n    \tDetails: - Input: Q8.7          -> Multiplied by 2^7")
    print("\t\t - Coefficients: Q1.14  -> Multiplied by 2^14")
    print("\t\t - Output: Q11.4         -> Multiplied by 2^4")
    print("\n\t2) Recap on Truncating the Final Filter Output to 16-bit")
    print("\n\tDetails: - Truncated from 35-bit to 16-bit")
    print("\t\t - Selected 33rd-bit to 18th-bit (32 downto 17 with indexing 34 to 0)")
    print("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")


    # ------------------------------------------------------------
    #            - Test Selection Menu -
    # ------------------------------------------------------------
    while True:
        print("\n=== Main Test Selection Menu ===")
        print("\nEnter the number of the test you want to view:\n")
        print("1) Single Input Test")
        print("2) Variable Input Sequences Test")
        print("3) End Tests and Exit")
        print("====================================\n")
        main_choice = input("Your choice: ")


        # === Main Menu Choice: Single Input Test Management ===
        if main_choice == '1':
            while True:
                print("\n--- Select the type of Single Test: ---\n")
                print("1) Test All 1 in convolution")
                print("2) Test All -1 in convolution")
                print("3) Test All 2 in convolution")
                print("4) Test All -2 in convolution")
                print("5) Test Maximum Positive Value (255.9921875)")
                print("6) Test Minimum Negative Value (-256.0)")
                print("7) Return to main menu")
                print("------------------------------------------------\n")

                single_test_choice = input("Your choice: ")

                if single_test_choice == '1':
                    # Test_1 Input Value: Single Impulse Response (All 1)
                    T1_input_real_value = 1.0
                    print("\n#####################################################################################")
                    print(f"#\tTest_(1): Results if input is all {T1_input_real_value} in convolution")
                    print("#####################################################################################")
                    print("\n\n✔️\t Test_(1) Started\t✔️ \n")
                    # Convolution
                    T1_scaled_total_sum= convolution_single_input(T1_input_real_value, scaled_coeff)
                    print_conv_results(T1_input_real_value, real_coeff, scaled_coeff, T1_scaled_total_sum)
                    print("\n✔️\t Test_(1) Completed\t✔️ \n")

                elif single_test_choice == '2':
                    # Test_2 Input Value: All -1
                    T2_input_real_value = -1.0
                    print("\n#####################################################################################")
                    print(f"#\tTest_(2): Results if input is all {T2_input_real_value} in convolution")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(2) Started\t✔️ \n")
                    # Convolution
                    T2_scaled_total_sum= convolution_single_input(T2_input_real_value, scaled_coeff)
                    print_conv_results(T2_input_real_value, real_coeff, scaled_coeff, T2_scaled_total_sum)
                    print("\n✔️\t Test_(2) Completed\t✔️ \n")

                elif single_test_choice == '3':
                    # Test_3 Input Value: All 2
                    T3_input_real_value = 2.0
                    print("\n#####################################################################################")
                    print(f"#\tTest_(3): Results if input is all {T3_input_real_value} in convolution")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(3) Started\t✔️ \n")
                    # Convolution
                    T3_scaled_total_sum= convolution_single_input(T3_input_real_value, scaled_coeff)
                    print_conv_results(T3_input_real_value, real_coeff, scaled_coeff, T3_scaled_total_sum)
                    print("\n✔️\t Test_(3) Completed\t✔️ \n")

                elif single_test_choice == '4':
                    # Test_4 Input Value: All -2
                    T4_input_real_value = -2.0
                    print("\n#####################################################################################")
                    print(f"#\tTest_(4): Results if input is all {T4_input_real_value} in convolution")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(4) Started\t✔️ \n")
                    # Convolution
                    T4_scaled_total_sum= convolution_single_input(T4_input_real_value, scaled_coeff)
                    print_conv_results(T4_input_real_value, real_coeff, scaled_coeff, T4_scaled_total_sum)
                    print("\n✔️\t Test_(4) Completed\t✔️ \n")

                elif single_test_choice == '5':
                    # -- Limit Test for representable values: [max_n: -256 | max_p: +255.9921875] --
                    # Test_5 Input Value: Maximum Positive Value
                    T5_input_real_value = 255.9921875
                    print("\n#####################################################################################")
                    print(f"#\tTest_(5): Results if input is all {T5_input_real_value} in convolution")
                    print(f"#\t-- Maximum Positive Value Representable --")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(5) Started\t✔️ \n")
                    # Convolution
                    T5_scaled_total_sum= convolution_single_input(T5_input_real_value, scaled_coeff)
                    print_conv_results(T5_input_real_value, real_coeff, scaled_coeff, T5_scaled_total_sum)
                    print("\n✔️\t Test_(5) Completed\t✔️ \n")

                elif single_test_choice == '6':
                    # Test_6 Input Value: Minimum Negative Value
                    T6_input_real_value = -256.0
                    print("\n#####################################################################################")
                    print(f"#\tTest_(6): Results if input is all {T6_input_real_value} in convolution")
                    print(f"#\t-- Minimum Negative Value Representable --")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(6) Started\t✔️ \n")
                    # Convolution
                    T6_scaled_total_sum= convolution_single_input(T6_input_real_value, scaled_coeff)
                    print_conv_results(T6_input_real_value, real_coeff, scaled_coeff, T6_scaled_total_sum)
                    print("\n✔️\t Test_(6) Completed\t✔️ \n")

                elif single_test_choice == '7':
                    break # Return to main menu
                else:
                    print("Invalid choice. Please try again.")

        # === Main Menu Choice: Sequence Test Management ===
        elif main_choice == '2':
            while True:
                print("\n--- Select the type of Sequence Test: ---\n")
                print("1) Test Sequence 1,2,3...23 in convolution (Sliding-Window Behavior)")
                print("2) Test Sequence -2,4,-2,4...-2 in convolution (Sliding-Window Behavior)")
                print("3) Test Sequence -1,-2,-1,-2...-1 in convolution (Sliding-Window Behavior)")
                print("4) Return to main menu")
                print("----------------------------------------------------------\n")

                sequence_test_choice = input("Your choice: ")

                if sequence_test_choice == '1':
                    # Test_7 Input Values: Increasing input values for convolution
                    T7_input_real_values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11, 12,
                                             13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]
                    print("\n#####################################################################################")
                    print(f"#\tTest_(7): Results if input is sequence:", end = " ")
                    print(f"{T7_input_real_values[0]}, {T7_input_real_values[1]}, {T7_input_real_values[2]}...", end="" )
                    print(f"{T7_input_real_values[22]}")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(7) Started\t✔️ \n")
                    # Convolution
                    T7_values_to_shift = list(range(23,0,-1)) # (reversed inputs)
                    T7_shifted_sequences = generate_sequence(T7_values_to_shift)
                    print_sliding_results(T7_shifted_sequences, scaled_coeff)
                    print("\n✔️\t Test_(7) Completed\t✔️ \n")

                elif sequence_test_choice == '2':
                    # Test_8 Input Values: Values -2 and 4
                    T8_input_real_values = [-2, 4, -2, 4, -2, 4, -2, 4, -2, 4, -2, 4,
                                             -2, 4, -2, 4, -2, 4, -2, 4, -2, 4, -2]
                    print("\n#####################################################################################")
                    print(f"#\tTest_(8): Results if input is sequence:", end = " ")
                    print(f"{T8_input_real_values[0]}, {T8_input_real_values[1]}, {T8_input_real_values[2]}, {T8_input_real_values[3]}...", end="" )
                    print(f"{T8_input_real_values[22]}")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(8) Started\t✔️ \n")
                    # Convolutions
                    T8_shifted_sequences = generate_sequence(T8_input_real_values)
                    print_sliding_results(T8_shifted_sequences, scaled_coeff)
                    print("\n✔️\t Test_(8) Completed\t✔️ \n")

                elif sequence_test_choice == '3':
                    # Test_9 Input Values: Values -1 and -2
                    T9_input_real_values = [-1, -2, -1, -2, -1, -2, -1, -2, -1, -2, -1, -2,
                                             -1, -2, -1, -2, -1, -2, -1, -2, -1, -2, -1]
                    print("\n#####################################################################################")
                    print(f"#\tTest_(9): Results if input is sequence:", end = " ")
                    print(f"{T9_input_real_values[0]}, {T9_input_real_values[1]}, {T9_input_real_values[2]}, {T9_input_real_values[3]}...", end="" )
                    print(f"{T9_input_real_values[22]}")
                    print("#####################################################################################")
                    print("\n✔️\t Test_(9) Started\t✔️ \n")
                    # Convolutions
                    T9_shifted_sequences = generate_sequence(T9_input_real_values)
                    print_sliding_results(T9_shifted_sequences, scaled_coeff)
                    print("\n✔️\t Test_(9) Completed\t✔️ \n")

                elif sequence_test_choice == '4':
                    break # Return to main menu
                else:
                    print("Invalid choice. Please try again.")

        # === Main Menu Choice: Program Termination ===
        elif main_choice == '3':
            print("\n--- Terminating tests. ---")
            break # Exit main loop
        else:
            print("Invalid choice. Please try again.")


if __name__ == "__main__":
    srrc_filter_test()
    print("\n\t✔️\tYou have Completed Viewing the Tests\t✔️ \n")