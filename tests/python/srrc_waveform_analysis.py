import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import upfirdn

"""
==========================================================================================================
  Author      : Gaetano Sferrazza
  Description : Python script used to test the behavior of the circuit that implements a filter
                (Squared Root Raised Cosine) SRRC_Fir, in various cases and more precisely
                'frequency_response_tests: out band/in band sinusoid filtering, Zero for ISI'. It therefore
                serves as a useful support tool to compare the values obtained with the results of the simulation
                conducted on ModelSim via its testbench (SRRC_Filter_waveform_tb). This will allow verifying if
                the results are consistent with those generated by this script (high-level), as they represent
                the expected values in case everything functions correctly.
                
  Purpose     : Created during the development of the project required for the
                'Electronics & Communications Systems' course exam - University of Pisa.

  Note: ModelSim is a digital circuit simulator used for functional verification of
        hardware designs described in VHDL, Verilog, or SystemVerilog.
==========================================================================================================

"""

def srrc_pulse(alpha, sps, span):
    """
    Generates a Square-Root Raised Cosine (SRRC) filter impulse response.

    This function calculates the tap coefficients for an SRRC filter based on
    the provided roll-off factor, samples per symbol, and filter span.
    The filter is commonly used in digital communications.

    Parameters:
        alpha (float): The roll-off factor (0 <= alpha <= 1). Controls the excess bandwidth.
        sps (int): Samples per symbol. Determines the sampling rate relative to the symbol rate.
        span (int): The duration of the filter in symbols. Defines the length of the impulse response.

    Returns:
        numpy.ndarray: An array containing the calculated SRRC filter coefficients.
    """
    t = np.linspace(-span / 2, span / 2, span * sps + 1)
    pi = np.pi
    eps = 1e-8
    pulse = np.zeros_like(t)
    for i in range(len(t)):
        if abs(t[i]) < eps:
            pulse[i] = 1 - alpha + (4 * alpha / pi)
        elif abs(abs(t[i]) - 1 / (4 * alpha)) < eps:
            pulse[i] = (alpha / np.sqrt(2)) * ((1 + 2 / pi) * np.sin(pi / (4 * alpha)) +
                                                (1 - 2 / pi) * np.cos(pi / (4 * alpha)))
        else:
            num = np.sin(pi * t[i] * (1 - alpha)) + \
                  4 * alpha * t[i] * np.cos(pi * t[i] * (1 + alpha))
            den = pi * t[i] * (1 - (4 * alpha * t[i])**2)
            pulse[i] = num / den

    return pulse

# === Filter Parameters ===
rolloff = 0.5
sps = 4          # Samples per symbol -> ( It corresponds to 'T' in frequency formula in the plot. E.g freq = 0.8/T in the Plot)
span = 6         # Number of symbols in the impulse response

# ====================================================================================
# -- Change the value (1, 2, 3 or 4) of the variable below to run the desired test --
TEST_MODE = 4
# ====================================================================================

# === Filter Generation ===
coeffs = srrc_pulse(rolloff, sps, span)

# === Test Selection ===
if TEST_MODE == 1:
    # Test 1: Impulse Response
    input_symbols = np.zeros(10)
    input_symbols[5] = 1.0
    upsampled = upfirdn([1], input_symbols, sps)
    title = "Test Single Impulse Response - (Python Simulation)"

elif TEST_MODE == 2:
    # Test 2: Zero ISI (impulses every T symbols)
    input_symbols = np.zeros(10)
    input_symbols[0::2] = 1.0
    input_symbols[1::2] = -1.0
    upsampled = upfirdn([1], input_symbols, sps)
    title = "Test Zero ISI with impulses +1/-1 alternated - (Python Simulation)"

elif TEST_MODE == 3:
    # Test 3: Out-of-band sinusoid
    t = np.arange(200)
    freq_out = 0.8 / sps  # Out of band (high attenuation)
    upsampled = np.sin(2 * np.pi * freq_out * t)
    title = "Test Out-of-band Sinusoid (freq = 0.8/T) - (Python Simulation)"

elif TEST_MODE == 4:
    # Test 4: In-band sinusoid (low attenuation)
    t = np.arange(200)
    freq_in = 0.1 / sps  # In band
    upsampled = np.sin(2 * np.pi * freq_in * t)
    title = "Test In-band Sinusoid (freq = 0.1/T) - (Python Simulation)"

else:
    raise ValueError("Invalid TEST_MODE. Use a number between 1 and 4.") # Updated range

# === Filtering ===
filtered_output = np.convolve(upsampled, coeffs)

# === Plot ===
plt.figure(figsize=(10, 4))
plt.plot(upsampled, '--', alpha=0.6, label="Input (Upsampled)", color='tab:orange')
plt.plot(filtered_output, label="SRRC Filter Output")
plt.title(title)
plt.xlabel("Samples")
plt.ylabel("Amplitude")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()


print("\t✔️\tTest Completed\t✔️ \n")

# === Saving for comparison with VHDL ===
# np.savetxt("reference_output.txt", filtered_output, fmt="%.6f")
# np.savetxt("input_symbols.txt", upsampled, fmt="%.6f")
# np.savetxt("srrc_coeffs.txt", h, fmt="%.6f")
# print("✔️  Files saved: 'reference_output.txt', 'input_symbols.txt', 'srrc_coeffs.txt'")